import type { Part, PluralPart } from '../../parser/src/types.mjs';
declare type TranslationParts<T extends BaseTranslation | BaseTranslation[] = BaseTranslation> = {
    [key in keyof T]: Part[];
};
export declare type Cache<T extends BaseTranslation | BaseTranslation[] = BaseTranslation> = TranslationParts<T>;
export declare type TranslationKey<T extends BaseTranslation | BaseTranslation[] = BaseTranslation> = keyof T;
declare const localized: unique symbol;
export declare type LocalizedString = string & {
    readonly [localized]: unknown;
};
declare type BaseTranslationFunction = (...args: Arguments) => LocalizedString;
export declare type TranslationFunctions<T extends BaseTranslation | BaseTranslation[] | Readonly<BaseTranslation> | Readonly<BaseTranslation[]> = BaseTranslation> = {
    [key in keyof T]: T[key] extends string ? BaseTranslationFunction : T[key] extends Record<any, any> ? TranslationFunctions<T[key]> : never;
};
declare type TypedTranslationFunction<Translation extends string, Formatters extends BaseFormatters> = (...args: Args<Translation, keyof Formatters>) => LocalizedString;
export declare type TypedTranslationFunctions<T extends BaseTranslation | BaseTranslation[] | Readonly<BaseTranslation> | Readonly<BaseTranslation[]> = BaseTranslation, Formatters extends BaseFormatters = BaseFormatters> = {
    [key in keyof T]: T[key] extends string ? TypedTranslationFunction<T[key], Formatters> : T[key] extends Record<any, any> ? TranslationFunctions<T[key]> : never;
};
export declare type Locale = string;
export declare type Arguments = any[];
export declare type BaseTranslation = {
    [key: number]: string | BaseTranslation | BaseTranslation[] | Readonly<string> | Readonly<BaseTranslation> | Readonly<BaseTranslation[]>;
} | {
    [key: string]: string | BaseTranslation | BaseTranslation[] | Readonly<string> | Readonly<BaseTranslation> | Readonly<BaseTranslation[]>;
} | string[] | Readonly<string[]>;
export declare type LocaleTranslations<L extends Locale, T = unknown> = {
    [key in L]: T;
};
export declare type FormattersInitializer<L extends Locale, F extends BaseFormatters> = (locale: L) => F;
export declare type FormatterFunction<T = any, U = unknown> = (value: T) => U;
export declare type BaseFormatters = {
    [formatter: string]: FormatterFunction;
};
declare type LocaleMappingBase = {
    locale: string;
    translations: BaseTranslation | BaseTranslation[];
};
/**
 * @deprecated
 */
export declare type LocaleMapping = ExportLocaleMapping;
export interface ExportLocaleMapping extends LocaleMappingBase {
    namespaces: string[];
}
export interface ImportLocaleMapping extends LocaleMappingBase {
    namespaces?: string[];
}
declare type Permutation<T extends string, U extends string = T> = [T] extends [never] ? Array<string> : T extends U ? [T, ...Permutation<Exclude<U, T>>] : [T];
declare type WrapParam<P> = P extends string ? `{${P}}` : never;
declare type ConstructString<Params extends unknown[]> = Params extends [] ? `${string}` : Params extends [infer Param, ...infer Rest] ? `${string}${WrapParam<Param>}${ConstructString<Rest>}` : Params extends string ? Params : `${string}`;
export declare type RequiredParams<Params extends string> = ConstructString<Permutation<Params>>;
export declare const isPluralPart: (part: Part) => part is PluralPart;
export declare const translate: (textParts: Part[], pluralRules: Intl.PluralRules, formatters: BaseFormatters, args: Arguments) => LocalizedString;
declare type GetArg<Arg extends string, Type> = Arg extends '' ? void : Arg extends `${infer OptionalArg}?` ? Partial<Record<OptionalArg, Type | undefined>> : Record<Arg, Type>;
declare type GetCaseType<Case extends string> = Case extends '*' ? string : Case;
declare type ExtractCase<CaseDefinition extends string> = CaseDefinition extends `${infer Case}:${string}` ? GetCaseType<Trim<Case>> : string;
declare type ExtractCases<SwitchCaseDefinition extends string> = SwitchCaseDefinition extends `${infer Case},${infer Rest}` ? [ExtractCase<Case>, ...ExtractCases<Rest>] : [ExtractCase<SwitchCaseDefinition>];
declare type SwitchCase<Arg extends string, SwitchCaseDefinition extends string> = GetArg<Arg, ExtractCases<SwitchCaseDefinition>[number]>;
declare type MergePipes<A, B> = A extends string ? A : B extends string ? B : A | B;
declare type PipeArgumentHelper<Piped extends string, Formatters extends PropertyKey, Type> = Piped extends Formatters ? Type : Piped extends '' ? Type : `unknown Formatter '${Piped}'`;
declare type PipeArgument<Arg extends string, Formatters extends PropertyKey, Piped extends string, Type> = Piped extends `${infer Pipe1}|${infer Rest}` ? MergePipes<PipeArgument<Arg, Formatters, Trim<Pipe1>, Type>, PipeArgument<Arg, Formatters, Trim<Rest>, Type>> : Piped extends `{${string}` ? Piped extends `${string}}` ? Piped extends `{${infer SwitchCaseDefinition}}` ? SwitchCase<Arg, Trim<SwitchCaseDefinition>> : PipeArgumentHelper<Piped, Formatters, Type> : PipeArgument<Arg, Formatters, `${Piped}}`, Type> : PipeArgumentHelper<Piped, Formatters, Type>;
declare type DetectType<Type extends string> = Type extends 'string' ? string : Type extends 'number' ? number : Type extends 'number[]' ? number[] : Type extends 'Array<number>' ? Array<number> : Type extends 'boolean' ? boolean : Type extends 'boolean[]' ? boolean[] : Type extends 'Array<boolean>' ? Array<boolean> : Type extends 'Date' ? Date : Type extends 'Date[]' ? Date[] : Type extends 'Array<Date>' ? Array<Date> : Type extends 'bigint' ? bigint : Type extends 'bigint[]' ? bigint[] : Type extends 'Array<bigint>' ? Array<bigint> : Type extends 'object' ? object : Type extends 'object[]' ? object[] : Type extends 'Array<object>' ? Array<object> : Type extends 'undefined' ? undefined : Type extends 'undefined[]' ? undefined[] : Type extends 'Array<undefined>' ? Array<undefined> : Type extends 'null' ? null : Type extends 'null[]' ? null[] : Type extends 'Array<null>' ? Array<null> : Type extends 'LocalizedString' ? LocalizedString : Type extends 'LocalizedString[]' ? LocalizedString[] : Type extends 'Array<LocalizedString>' ? Array<LocalizedString> : unknown;
declare type Empty = ' ' | '\n' | '\t';
declare type TrimL<S extends string> = S extends `${Empty}${infer L}` ? TrimL<L> : S;
declare type TrimR<S extends string> = S extends `${infer L}${Empty}` ? TrimR<L> : S;
declare type Trim<S extends string> = TrimR<TrimL<S>>;
declare type DefineArg<Arg extends string, Formatters extends PropertyKey> = Arg extends `${infer Arg1}}${infer Arg2}` ? Merge<[DefineArg<Arg1, Formatters>], DetectArgs<Arg2, Formatters>> : Arg extends `${infer Arg}:${infer Type}|${infer Piped}` ? PipeArgument<Arg, Formatters, Trim<Piped>, GetArg<Trim<Arg>, DetectType<Trim<Type>>>> : Arg extends `${infer Arg}|${infer Piped}` ? PipeArgument<Arg, Formatters, Trim<Piped>, GetArg<Trim<Arg>, unknown>> : Arg extends `${infer Arg}:${infer Type}` ? GetArg<Trim<Arg>, DetectType<Trim<Type>>> : GetArg<Trim<Arg>, unknown>;
declare type DetectArg<Part extends string, Formatters extends PropertyKey> = Part extends `{${string}}` ? [] : [DefineArg<Part, Formatters>];
declare type Merge<A extends Array<unknown>, B extends Array<unknown>> = void extends A[number] ? void extends B[number] ? unknown : B[number] : void extends B[number] ? A[number] : A[number] & B[number];
declare type DetectArgs<Translation extends string, Formatters extends PropertyKey> = Translation extends `${infer Before}{{${string}}}${infer Rest}` ? [Merge<DetectArgs<Before, Formatters>, DetectArgs<Rest, Formatters>>] : Translation extends `${string}{${infer Arg}}}${infer Rest}` ? [Merge<DetectArg<`${Arg}}`, Formatters>, DetectArgs<Rest, Formatters>>] : Translation extends `${string}{${infer Arg}}${infer Rest}` ? [Merge<DetectArg<Arg, Formatters>, DetectArgs<Rest, Formatters>>] : unknown[];
export declare type Args<Translation extends string, Formatters extends PropertyKey> = Translation extends `${string}{${string}}${string}` ? DetectArgs<Translation, Formatters> : never;
export {};
