{
  "version": 3,
  "sources": ["../../.pnpm/typesafe-i18n@5.15.0_typescript@4.8.4/node_modules/typesafe-i18n/runtime/esm/parser/src/index.mjs", "../../.pnpm/typesafe-i18n@5.15.0_typescript@4.8.4/node_modules/typesafe-i18n/runtime/esm/runtime/src/core.mjs", "../../.pnpm/typesafe-i18n@5.15.0_typescript@4.8.4/node_modules/typesafe-i18n/runtime/esm/runtime/src/util.string.mjs", "../../.pnpm/typesafe-i18n@5.15.0_typescript@4.8.4/node_modules/typesafe-i18n/runtime/esm/runtime/src/util.object.mjs", "../../.pnpm/typesafe-i18n@5.15.0_typescript@4.8.4/node_modules/typesafe-i18n/runtime/esm/runtime/src/util.instance.mjs"],
  "sourcesContent": ["// --------------------------------------------------------------------------------------------------------------------\n// eslint-disable-next-line prettier/prettier\nconst removeEmptyValues = (object) => Object.fromEntries(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nObject.entries(object)\n    .map(([key, value]) => key !== 'i' && value && value != '0' && [key, value])\n    .filter(Boolean));\n// --------------------------------------------------------------------------------------------------------------------\nconst trimAllValues = (part) => Object.fromEntries(Object.keys(part).map((key) => {\n    const val = part[key];\n    return [\n        key,\n        Array.isArray(val) ? val.map((v) => v === null || v === void 0 ? void 0 : v.trim()) : val === !!val ? val : val === null || val === void 0 ? void 0 : val.trim(),\n    ];\n}));\n// --------------------------------------------------------------------------------------------------------------------\nconst parseArgumentPart = (text) => {\n    const [keyPart = '', ...formatterKeys] = text.split('|');\n    const [keyWithoutType = '', type] = keyPart.split(':');\n    const [key, isOptional] = keyWithoutType.split('?');\n    return { k: key, i: type, n: isOptional === '', f: formatterKeys };\n};\n// --------------------------------------------------------------------------------------------------------------------\nconst parsePluralPart = (content, lastAccessor) => {\n    let [key, values] = content.split(':');\n    if (!values) {\n        values = key;\n        key = lastAccessor;\n    }\n    const entries = values.split('|');\n    const [zero, one, two, few, many, rest] = entries;\n    const nrOfEntries = entries.filter((entry) => entry !== undefined).length;\n    if (nrOfEntries === 1) {\n        return { k: key, r: zero };\n    }\n    if (nrOfEntries === 2) {\n        return { k: key, o: zero, r: one };\n    }\n    if (nrOfEntries === 3) {\n        return { k: key, z: zero, o: one, r: two };\n    }\n    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };\n};\n// --------------------------------------------------------------------------------------------------------------------\nconst REGEX_BRACKETS_SPLIT = /(\\{(?:[^{}]+|\\{(?:[^{}]+)*\\})*\\})/g;\nexport const removeOuterBrackets = (text) => text.substring(1, text.length - 1);\nexport const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText\n    .split(REGEX_BRACKETS_SPLIT)\n    .map((part) => {\n    if (!part.match(REGEX_BRACKETS_SPLIT)) {\n        return part;\n    }\n    const content = removeOuterBrackets(part);\n    if (content.startsWith('{')) {\n        return parsePluralPart(removeOuterBrackets(content), lastKey);\n    }\n    const parsedPart = parseArgumentPart(content);\n    lastKey = parsedPart.k || lastKey;\n    !firstKey && (firstKey = lastKey);\n    return parsedPart;\n})\n    .map((part) => {\n    if (typeof part === 'string')\n        return part;\n    if (!part.k)\n        part.k = firstKey || '0';\n    const trimmed = trimAllValues(part);\n    return optimize ? removeEmptyValues(trimmed) : trimmed;\n});\n", "import { removeOuterBrackets } from '../../parser/src/index.mjs';\n// --------------------------------------------------------------------------------------------------------------------\n// implementation -----------------------------------------------------------------------------------------------------\n// --------------------------------------------------------------------------------------------------------------------\nexport const isPluralPart = (part) => !!(part.o || part.r);\nconst REGEX_SWITCH_CASE = /^\\{.*\\}$/;\nconst applyFormatters = (formatters, formatterKeys, initialValue) => formatterKeys.reduce((value, formatterKey) => {\n    var _a, _b;\n    return (_b = (formatterKey.match(REGEX_SWITCH_CASE)\n        ? (() => {\n            var _a;\n            const cases = Object.fromEntries(removeOuterBrackets(formatterKey)\n                .split(',')\n                .map((part) => part.split(':').map((value) => value.trim())));\n            return (_a = cases[value]) !== null && _a !== void 0 ? _a : cases['*'];\n        })()\n        : (_a = formatters[formatterKey]) === null || _a === void 0 ? void 0 : _a.call(formatters, value))) !== null && _b !== void 0 ? _b : value;\n}, initialValue);\nconst getPlural = (pluralRules, { z, o, t, f, m, r }, value) => {\n    switch (z && value == 0 ? 'zero' : pluralRules.select(value)) {\n        case 'zero':\n            return z;\n        case 'one':\n            return o;\n        case 'two':\n            return t;\n        case 'few':\n            return f;\n        case 'many':\n            return m;\n        default:\n            return r;\n    }\n};\nconst REGEX_PLURAL_VALUE_INJECTION = /\\?\\?/g;\nconst applyArguments = (textParts, pluralRules, formatters, args) => textParts\n    .map((part) => {\n    if (typeof part === 'string') {\n        return part;\n    }\n    const { k: key = '0', f: formatterKeys = [] } = part;\n    const value = args[key];\n    if (isPluralPart(part)) {\n        return ((typeof value === 'boolean' ? (value ? part.o : part.r) : getPlural(pluralRules, part, value)) || '').replace(REGEX_PLURAL_VALUE_INJECTION, value);\n    }\n    const formattedValue = formatterKeys.length ? applyFormatters(formatters, formatterKeys, value) : value;\n    return ('' + (formattedValue !== null && formattedValue !== void 0 ? formattedValue : '')).trim();\n})\n    .join('');\nexport const translate = (textParts, pluralRules, formatters, args) => {\n    const firstArg = args[0];\n    const isObject = firstArg && typeof firstArg === 'object' && firstArg.constructor === Object;\n    const transformedArgs = (args.length === 1 && isObject ? firstArg : args);\n    return applyArguments(textParts, pluralRules, formatters, transformedArgs);\n};\n// type TransformArgsArray<A extends Array<Record<string, unknown>>> = keyof A[0] extends `${number}`\n// \t? ToIndexBasedArgs<A>\n// \t: A\n// type ToIndexBasedArgs<A extends Array<Record<string, unknown>>, B extends keyof A[0] = keyof A[0]> = GetTypesFromRecord<\n// \tA[0],\n// \tSort<ToNumberArray<ToTuple<B>>>\n// >\n// type GetTypesFromRecordAsArray<A extends Record<string, unknown>, B extends unknown[]> = B extends [infer Item, ...infer Rest]\n// \t? [A[Item], ...XX<A, Rest>]\n// \t: []\n// type UnionToParm<U> = U extends any ? (k: U) => void : never\n// type UnionToSect<U> = UnionToParm<U> extends (k: infer I) => void ? I : never\n// type ExtractParm<F> = F extends { (a: infer A): void } ? A : never\n// type SpliceOne<Union> = Exclude<Union, ExtractOne<Union>>\n// type ExtractOne<Union> = ExtractParm<UnionToSect<UnionToParm<Union>>>\n// type ToTuple<Union> = ToTupleRec<Union, []>\n// type ToTupleRec<Union, Rslt extends any[]> = SpliceOne<Union> extends never\n// \t? [ExtractOne<Union>, ...Rslt]\n// \t: ToTupleRec<SpliceOne<Union>, [ExtractOne<Union>, ...Rslt]>\n// type GenList<N, A extends any[] = []> = N extends A['length'] ? A : GenList<N, [0, ...A]>\n// // Add lists of size: [1, 2] -> [[1, [_]], [2, [_, _]]]\n// type Expand<T extends any[]> = T extends [infer Head, ...infer Rest] ? [[Head, GenList<Head>], ...Expand<Rest>] : []\n// // Drop one from each list, remove whole pair for empty: [[1, [_]], [0, []], [2, [_, _]]] -> [[1, []], [2, [_]]]\n// type DropAndFilter<T> = T extends [infer First, ...infer Rest]\n// \t? First extends [any, []]\n// \t\t? DropAndFilter<Rest>\n// \t\t: First extends [infer N, [any, ...infer NREST]]\n// \t\t? [[N, NREST], ...DropAndFilter<Rest>]\n// \t\t: []\n// \t: []\n// // [[1, []], [2, [_]]] -> [1]\n// type FindEmpty<T> = T extends [infer First, ...infer Rest]\n// \t? First extends [infer N, []]\n// \t\t? [N, ...FindEmpty<Rest>]\n// \t\t: FindEmpty<Rest>\n// \t: []\n// // Sort expanded\n// type Condense<T extends [number, any[]][], Result extends number[] = []> = T extends []\n// \t? Result\n// \t: Condense<DropAndFilter<T>, [...Result, ...FindEmpty<T>]>\n// type Reverse<A extends any[]> = A extends [infer H, ...infer T] ? [...Reverse<T>, H] : []\n// type Sort<T extends any[], R = false> = R extends true ? Reverse<Condense<Expand<T>>> : Condense<Expand<T>>\n// type ToNumberArray<T extends unknown[]> = T extends [infer Item, ...infer Rest]\n// \t? [ToNumber<Item>, ...ToNumberArray<Rest>]\n// \t: []\n// type ToNumber<S, L extends number[] = []> = `${L['length']}` extends S ? L['length'] : ToNumber<S, [...L, 0]>\n", "import { parseRawText } from '../../parser/src/index.mjs';\nimport { translate } from './core.mjs';\nexport const getPartsFromString = (cache, text) => cache[text] || (cache[text] = parseRawText(text));\nconst translateString = (cache, pluralRules, formatters, text, ...args) => translate(getPartsFromString(cache, text), pluralRules, formatters, args);\nexport const i18nString = (locale, formatters = {}) => translateString.bind(null, {}, new Intl.PluralRules(locale), formatters);\nexport const typesafeI18nString = (locale, formatters = {}) => translateString.bind(null, {}, new Intl.PluralRules(locale), formatters);\n", "import { translate } from './core.mjs';\nimport { getPartsFromString } from './util.string.mjs';\nconst getTranslateInstance = (locale, formatters) => {\n    const cache = {};\n    const pluralRules = new Intl.PluralRules(locale);\n    return (text, ...args) => translate(getPartsFromString(cache, text), pluralRules, formatters, args);\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function i18nObject(locale, translations, formatters = {}) {\n    return createProxy(translations, getTranslateInstance(locale, formatters));\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function typesafeI18nObject(locale, translations, formatters = {}) {\n    return createProxy(translations, getTranslateInstance(locale, formatters));\n}\nconst wrap = (proxyObject = {}, translateFn) => (typeof proxyObject === 'string'\n    ? translateFn.bind(null, proxyObject)\n    : Object.assign(Object.defineProperty(() => '', 'name', { writable: true }), proxyObject));\n/* PROXY-START */\nconst createProxy = (proxyObject, translateFn) => new Proxy(wrap(proxyObject, translateFn), {\n    get: (target, key) => {\n        if (key === Symbol.iterator)\n            return [][Symbol.iterator].bind(Object.values(target).map((entry) => wrap(entry, translateFn)));\n        return createProxy(target[key], translateFn);\n    },\n});\n/* PROXY-END */\n\n", "import { i18nObject } from './util.object.mjs';\nexport const i18n = (translations, formatters) => {\n    const cache = {};\n    return new Proxy({}, {\n        get: (_target, locale) => cache[locale] || (cache[locale] = i18nObject(locale, translations[locale], formatters[locale])),\n    });\n};\n"],
  "mappings": "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",
  "names": ["_a", "value"]
}
